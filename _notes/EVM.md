---

---

# Overview

Ethereum Virtual Machine (또는 EVM ) 은 Ethereum 내부의 스마트 컨트랙트를 위한 런타임 환경입니다. 이것은 샌드박스일 뿐만 아니라 완전히 고립된 환경입니다. 이것은 EVM 안에서 코드를 돌리는 것이 네트워크, 파일시스켐, 또는 다른 프로세스에 접근할 권한이 전혀 없다는 것을 뜻합니다. 뿐만 아니라 스마트 컨트렉트는 다른 스마트 컨트렉트에도 제한된 접근 권한만 가지고 있습니다. 

---
# Accounts
Ehereum에는 같은 주소 공간을 공유하는 account 는 두가지 종류가 있습니다. 공개-개인키 쌍에 의해 제어되는 External accounts와 저장된 코드에 의해 제어되는 contract account 입니다.

`external account` 의 주소는 public key 에서 판단되는 반면, `contact account` 는 계약이 생성될 때 결정됩니다(작성자 주소와 그 주소에서 보낸 거래 수, 소위 "nonce"에서 파생됩니다).

계정이 코드를 저장 하는지 여부에 관계없이, 두 유형은 EVM에 의해 동등하게 취급됩니다.

모든 account 는 256 비트 단어를 매핑하는 Storage 라고 불리는 key-value 저장소가 있습니다.

게다가 모든 계정은 이더에 대한 잔액(balance)을 가지고 있으며(정확히는 Wei 에서, 1 에테르는 10^18we) 이더를 포함하는 거래를 보내 수정할 수 있습니다.

---
# transactions

>***트렌젝션은 거래라고 부르면 되는데, 우리나라에서도 트렌젝션이라고 부르는 거 같애서 트렌젝션이라고 적겠습니다.*** 

트랜잭션은 한 계정에서 다른 계정으로 보내지는 메세지입니다(같을수도 비어있을 수도 있습니다. 아래를 참고하세요.). 이것은 (페이로드라고 불리는) 바이너리 데이터나 Ether 를 포함합니다. 수신 계정에 코드가 포함되어 있다면, 코드는 실행되고 페이로드는 입력 데이터로 들어갑니다.

수신 계정이 아직 준비가 되지 않았으면(트랜젝션에 수신자가 없거나, 수신자가 null 로 되어있음), 이 트랜잭션은 새로운 contract 를 만드는 시도로 해석합니다. 이미 얘기했듯이 contract 의 주소는 zero address 가 아니라 발신자와 전송된 거래 수(nonce) 에서 파생된 주소입니다.

> 컨트렉트의 주소는 발신자의 주소와 지금까지 보낸 트랜젝션의 수(nonce)로 결정된다는 사실을 기억하세요 address 항목에 정리되어있습니다.

이런 contract 의 생성에 대한 트렌잭션의 페이로드(바이너리)는 EVM 바이트코드에 가고 실행됩니다. 이 실행의 출력은 contract 의 코드에 영구적으로 저장됩니다. 이것은 contract 를 만드려 할 때 당신은 해당 코드를 직접 보내는 것이 아니라 실행되고 난 코드가 보내지는 것을 뜻합니다.

```
contract 가 생성되는 동안 이 코드는 여전히 비어있습니다. 이것 때문에 당신은 코드의 실행이 끝나기 전에는 contract의 생성자 안에서는 contract 안으로 callback 하지 않아야 합니다.
```

---
# Gas
생성할 때 각 트랜잭션은 일정량의 Gas 를 부과받습니다. 이것은 트랜잭션의 창시자에게 부과됩니다. (tx.origin) EVM 이 트랜잭션을 실행하는 동안 gas 는 특정한 규칙에 따라서 점차 고갈됩니다. 가스가 어느 시점에서든 소진되면(음수가 될 것입니다.) out-of-gas 예외가 트리거되어 실행을 종료하고, 현재 호출 프레임의 상태로 이루어진 모든 수정을 되돌릴 수 있습니다.

이 메커니즘은 EVM 실행 시간의 경제적 사용을 장려하고 또한 EVM 집행자(즉, 광부/도표자)의 작업에 대해 보상합니다. 각 블록은 최대 양의 가스를 가지고 있기 때문에, 또한 블록을 검증하는 데 필요한 작업의 양을 제한합니다.

gas price 는 트렌잭션의 창시자에 의해서 결정되는 값이며, `gas_price * gas` 만큼 EVM executor (EVM 메커니즘입니다.) 에게 지불해야 합니다. 실행 후에 gas가 약간 남아있으면, 트렌잭션의 창시자에게 환급됩니다. 변동사항이 되돌아가는 예외에 사용된 gas 는 환불되지 않습니다.

EVM executor 들이 트랜잭션을 포함할지 말지 선택할 수 있기 때문에, 트랜잭션 발신자들은 낮은 가스 가격을 설정하여 시스템을 남용할 수 없습니다. 

---
# Storage, Memory and the Stack
Ethereum Virtual Machine 은 storage, memory 와 stack 이라는 3개의 저장구역이 있습니다.
## Storage
각각의 계정은 storage 라고 불리는 데이터 영역이 있고, 이것은 함수 call 과 transaction 에서도 영구적인 데이터 영역이 됩니다. 스토리지는 256비트 단어를 256비트 단어로 매핑하는 key-value 저장소입니다. 

> 보통 이 곳에는 컨트렉트의 현재 상태를 나타내기 위해 토큰 총 공급량, 컨트랙트 소유자 주소, 주소별 토큰 잔액, 컨트렉트 관리자 목록과 같은 정보 들이 mapping 되어 들어갑니다.

이것을 읽는 것도 비용이 많이 들고, 저장소를 초기화하고 수정하는 것은 훨씬 더 비쌉니다. 이 가격때문에 영구적인 storage 에 저장하는 행위를 최적화해야 합니다. 계약 외부에서 파생된 계산, 캐싱 및 집계와 같은 데이터를 저장하세요. 계약은 그 자체를 제외하고는 어떤 저장소에도 읽거나 쓸 수 없습니다.
## Memory
두번째 데이터 영역은 memory 라고 불리고, 컨트렉트는 메세지 call 마다 깨끗하게 지워진 인스턴스를 얻습니다. 메모리는 선형적이고 바이트레벨에서 처리될 수 있습니다. 하지만 읽는것은 256비트단위로 제한되는 반면, 쓰기는 8비트와 256 비트를 선택할 수 있습니다.
메모리는 이전에 손대지 않은 메모리 단어(즉, 단어 내의 오프셋)에 접근할 때(읽기 또는 쓰기) 단어(256비트)로 확장됩니다. 확장 시, 가스 비용을 지불해야 합니다. 메모리는 커질수록 비용이 더 많이 듭니다(이차적으로 확장).

>예시코드를 살펴보면, 생성자에 매개변수를 Memory 로 받고, 이것을 contract 내부에 있는 중요한 상태변수에 넣는데, 이것을 Storage 로 관리하는 것을 볼 수 있는데, 대표적인 사용 예시라고 생각됩니다.


EVM은 레지스터 기반 기계가 아니라 스택 기반 기계입니다. 따라서 모든 계산은 '스택'이라고 불리는 데이터 영역에서 수행됩니다. 스택은 최대 1024개의 요소를 가질 수 있으며, 각 요소는 256비트 단어입니다. 스택에 대한 접근은 다음과 같이 상단으로 제한됩니다:

- 최상위 16개 요소 중 하나를 스택의 맨 위로 복사하거나,
- 최상위 요소를 그 아래 16개 요소 중 하나와 교환할 수 있습니다.

다른 모든 연산은 스택의 최상위 두 개(또는 연산에 따라 하나 혹은 그 이상의) 요소를 가져와 처리하고, 그 결과를 다시 스택의 맨 위에 넣습니다. 물론 스택의 더 깊은 부분에 접근하기 위해 스택 요소들을 스토리지나 메모리로 이동시킬 수는 있습니다. 하지만 스택의 상단을 먼저 제거하지 않고서는 스택의 임의의 깊은 요소에 직접 접근하는 것은 불가능합니다.

---
# [Instruction Set](https://docs.soliditylang.org/en/v0.8.26/introduction-to-smart-contracts.html#instruction-set)

나중에 정리.